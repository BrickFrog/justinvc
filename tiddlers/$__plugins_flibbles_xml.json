{
    "tiddlers": {
        "$:/plugins/flibbles/xml/config.js": {
            "title": "$:/plugins/flibbles/xml/config.js",
            "text": "/*\\\ntitle: $:/plugins/flibbles/xml/config.js\ntype: application/javascript\nmodule-type: config\n\nAdds global configurations used by tw5-xml to $tw.config, where they can\nbe hacked if necessary.\n\\*/\n\nexports.xml = Object.create(null);\n\nexports.xml.supportedDocumentTypes = {\n\t\"text/html\": \"text/html\",\n\t\"text/xml\": \"text/xml\",\n\t\"application/xml\": \"application/xml\",\n\t\"application/xhtml+xml\": \"application/xhtml+xml\",\n\t\"image/svg+xml\": \"image/svg+xml\"\n};\n",
            "type": "application/javascript",
            "module-type": "config"
        },
        "$:/plugins/flibbles/xml/deserializer.js": {
            "title": "$:/plugins/flibbles/xml/deserializer.js",
            "text": "/*\\\nmodule-type: tiddlerdeserializer\ntitle: $:/plugins/flibbles/xml/deserializer.js\ntype: application/javascript\n\nDeserializes xml files of type:\n<tiddlers>\n <tiddler>\n  <title>Some title</title>\n  <text>body</text>\n  <otherfield>field value</otherfield>\n  ...\n </tiddler>\n ...\n</tiddler>\n\n\\*/\n\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar xmldom = require(\"./xmldom\");\n\nexports[\"text/xml\"] = function(text,fields) {\n\tvar doc = xmldom.getDocumentForText(\"text/xml\", text);\n\tvar attributes = xmldom.getProcessingInstructions(doc);\n\tif (!doc.error || !probablyBundle(text)) {\n\t\tif (!attributes.bundle) {\n\t\t\treturn [basicXml(text,fields)];\n\t\t} else if (!doc.error) {\n\t\t\ttry {\n\t\t\t\treturn deserializeTiddlers(doc.documentElement);\n\t\t\t} catch (e) {\n\t\t\t\t// proceed to error handling below. Ignore message for now.\n\t\t\t}\n\t\t}\n\t}\n\t// It's malformed. Don't try to parse it.\n\tvar logger = new $tw.utils.Logger(\"XML deserializer\"),\n\t\terror = $tw.language.getString(\n\t\t\t\"flibbles/xml/Error/BundleParserError\",\n\t\t\t{variables: { file: fields.title } });\n\tlogger.alert(error);\n\treturn [];\n};\n\nfunction probablyBundle(text) {\n\treturn (text.match(/<\\?tiddlywiki\\s(?:[^\\?]|\\?[^>])*\\bbundle[\\s\\?]/));\n};\n\nfunction basicXml(text, fields) {\n\tvar rtn = $tw.utils.extend(Object.create(null), fields);\n\trtn.text = text;\n\trtn.type = \"text/xml\";\n\treturn rtn;\n};\n\nfunction deserializeTiddlers(domNode) {\n\tvar results = [];\n\tif (domNode.tagName === \"tiddlers\") {\n\t\tvar incomingFields = domNode.firstChild;\n\t\twhile (incomingFields) {\n\t\t\tif (incomingFields.tagName === \"tiddler\") {\n\t\t\t\tresults.push(deserializeTiddler(incomingFields));\n\t\t\t} else if (incomingFields.tagName !== undefined) {\n\t\t\t\tthrow \"Expected <tiddler> element. Got <\"+incomingFields.tagName+\">\";\n\t\t\t}\n\t\t\tincomingFields = incomingFields.nextSibling;\n\t\t}\n\t} else if (domNode.tagName === \"tiddler\") {\n\t\tresults.push(deserializeTiddler(domNode));\n\t} else {\n\t\tthrow \"Root element must be <tiddlers> or <tiddler>\";\n\t}\n\treturn results;\n};\n\nfunction deserializeTiddler(domNode) {\n\tvar fields = Object.create(null);\n\tvar node = domNode.firstChild;\n\twhile (node) {\n\t\tif (node.tagName !== undefined) {\n\t\t\tif (node.childNodes.length == 1) {\n\t\t\t\tif (node.firstChild.nodeType == 3 /* text */) {\n\t\t\t\t\tfields[node.tagName] = node.firstChild.data;\n\t\t\t\t} else if (node.firstChild.nodeType == 4 /* CDATA */) {\n\t\t\t\t\tfields[node.tagName] = node.textContent;\n\t\t\t\t} else {\n\t\t\t\t\t// Comment? It's a comment, right?\n\t\t\t\t\tfields[node.tagName] = node.innerHTML;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// This field appears to be written as unescaped XML.\n\t\t\t\t// Very well. We'll still take it.\n\t\t\t\tfields[node.tagName] = node.innerHTML;\n\t\t\t}\n\t\t}\n\t\tnode = node.nextSibling;\n\t}\n\treturn fields;\n};\n\n})();\n",
            "module-type": "tiddlerdeserializer",
            "type": "application/javascript"
        },
        "$:/language/Docs/Types/text/xml": {
            "title": "$:/language/Docs/Types/text/xml",
            "description": "XML document",
            "group": "Developer",
            "name": "text/xml"
        },
        "$:/plugins/flibbles/xml/exporters/XmlFile": {
            "title": "$:/plugins/flibbles/xml/exporters/XmlFile",
            "description": "XML file",
            "extension": ".xml",
            "tags": "$:/tags/Exporter",
            "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<?tiddlywiki bundle?>\n&lt;tiddlers><$set name=\"_filter\" value=<<exportFilter>>><$list filter=<<_filter>> >&lt;tiddler><$list variable=\"field\" filter=\"[<currentTiddler>fields[]]\">&lt;<$text text=<<field>> />><$view field=<<field>> format=\"htmlencoded\" />&lt;/<$text text=<<field>> />></$list>&lt;/tiddler></$list></$set>&lt;/tiddlers>"
        },
        "$:/plugins/flibbles/xml/filetype.js": {
            "title": "$:/plugins/flibbles/xml/filetype.js",
            "text": "/*\\\nmodule-type: startup\ntitle: $:/plugins/flibbles/xml/filetype.js\ntype: application/javascript\n\nThis takes care of registering the xml filetype.\n\n\\*/\n\n// This is technically incorrect. An XML file might not necessarily be\n// utf-8, but Tiddlywiki doesn't have a mechanism that allows us to be\n// dynamic about it.\n$tw.utils.registerFileType(\"text/xml\", \"utf8\", \".xml\");\n",
            "module-type": "startup",
            "type": "application/javascript"
        },
        "$:/plugins/flibbles/xml/filters.js": {
            "title": "$:/plugins/flibbles/xml/filters.js",
            "text": "/*\\\ntitle: $:/plugins/flibbles/xml/filters.js\ntype: application/javascript\nmodule-type: filteroperator\n\nFilter operator for applying xpath queries to incoming tiddler titles.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar xmldom = require(\"./xmldom\");\nvar xpath = require(\"./xpath\");\nvar xselect = require(\"./xselect\");\n\nfunction filterInput(source,operator,options,queryMethod,errorMethod) {\n\tvar query = operator.operand,\n\t\tresults = [],\n\t\tifQuery = operator.suffix === \"if\",\n\t\tnegate = operator.prefix === \"!\";\n\n\tsource(function(tiddler,title) {\n\t\tvar doc = options.wiki.getTiddlerDocument(tiddler);\n\t\tif (!doc) {\n\t\t\tif (ifQuery && negate) {\n\t\t\t\tresults.push(title);\n\t\t\t}\n\t\t} else if (doc.error) {\n\t\t\tif (ifQuery) {\n\t\t\t\tif (negate) {\n\t\t\t\t\tresults.push(title);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (doc) {\n\t\t\t\t\tresults.push(doc.error);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tvar iterator = queryMethod(query, doc);\n\t\t\t\tvar node = iterator.iterateNext();\n\t\t\t\tif (ifQuery) {\n\t\t\t\t\tif (!node == negate) {\n\t\t\t\t\t\tresults.push(title);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (node) {\n\t\t\t\t\t\tresults.push(xmldom.getStringValue(node));\n\t\t\t\t\t\tnode = iterator.iterateNext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tvar msg = errorMethod(e, query, title);\n\t\t\t\tif (results.indexOf(msg) < 0) {\n\t\t\t\t\tresults.push(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\treturn results;\n};\n\nexports.xpath = function(source,operator,options) {\n\treturn filterInput(source,operator,options, function(xpathQuery, contextNode) {\n\t\tvar resolver = xpath.createResolver(contextNode, options.widget);\n\t\tvar iterator = xpath.evaluate(xpathQuery, contextNode, resolver);\n\t\treturn iterator;\n\t}, xpath.getError);\n};\n\nexports.xselect = function(source,operator,options) {\n\treturn filterInput(source, operator, options, xselect.querySelectorAll, xselect.getError);\n};\n\n})();\n",
            "type": "application/javascript",
            "module-type": "filteroperator"
        },
        "$:/language/flibbles/xml/Error/BundleParserError": {
            "title": "$:/language/flibbles/xml/Error/BundleParserError",
            "text": "Unable to parse XML tiddler bundle in file: <$text text=<<file>> />"
        },
        "$:/language/flibbles/xml/Error/DOMParserError": {
            "title": "$:/language/flibbles/xml/Error/DOMParserError",
            "text": "Unable to parse XML in tiddler \"<$text text=<<currentTiddler>> />\""
        },
        "$:/language/flibbles/xml/Error/XSelect/SyntaxError": {
            "title": "$:/language/flibbles/xml/Error/XSelect/SyntaxError",
            "text": "Invalid Selector: <$text text=<<xselect>> />"
        },
        "$:/language/flibbles/xml/Error/XPath/NamespaceError": {
            "title": "$:/language/flibbles/xml/Error/XPath/NamespaceError",
            "text": "Could not resolve namespaces in XPath expression \"<<xpath>>\" for tiddler \"<$text text=<<currentTiddler>> />\""
        },
        "$:/language/flibbles/xml/Error/XPath/SyntaxError": {
            "title": "$:/language/flibbles/xml/Error/XPath/SyntaxError",
            "text": "Invalid XPath expression: <$text text=<<xpath>> />"
        },
        "$:/language/flibbles/xml/Error/XPath/UnsupportedBrowserError": {
            "title": "$:/language/flibbles/xml/Error/XPath/UnsupportedBrowserError",
            "text": "This browser does not support XPath"
        },
        "$:/language/flibbles/xml/Error/XPath/MissingDependenciesError": {
            "title": "$:/language/flibbles/xml/Error/XPath/MissingDependenciesError",
            "text": "xpath dependency is required on Node.JS for this operation. Install xpath with `npm install xpath`"
        },
        "$:/plugins/flibbles/xml/parsers/xmlparser.js": {
            "title": "$:/plugins/flibbles/xml/parsers/xmlparser.js",
            "text": "/*\\\ntitle: $:/plugins/flibbles/xml/parsers/xmlparser.js\ntype: application/javascript\nmodule-type: parser\n\nThe XML parser displays itself as xml.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar xmldom = require(\"../xmldom\");\n\nvar XmlParser = function(type,text,options) {\n\tvar doc = xmldom.getDocumentForText(\"text/xml\", text);\n\tvar templateValue = xmldom.getProcessingInstructions(doc).template;\n\tif (templateValue) {\n\t\tthis.tree = [{\n\t\t\ttype: \"transclude\",\n\t\t\tattributes: {\n\t\t\t\ttiddler: templateValue\n\t\t\t},\n\t\t\tisBlock: true\n\t\t}];\n\t} else {\n\t\tthis.tree = [{\n\t\t\ttype: \"codeblock\",\n\t\t\tattributes: {\n\t\t\t\tcode: {type: \"string\", value: text},\n\t\t\t\tlanguage: {type: \"string\", value: \"xml\"}\n\t\t\t}\n\t\t}];\n\t}\n};\n\nexports[\"text/xml\"] = XmlParser;\n\n})();\n",
            "type": "application/javascript",
            "module-type": "parser"
        },
        "$:/plugins/flibbles/xml/readme": {
            "title": "$:/plugins/flibbles/xml/readme",
            "text": "''tw5-xml'' supplies tools for working with XML tiddlers.\n\n!!! Features\n\n* Query XML and HTML with XPath using the `xpath` widget and operator.\n* Query XML and HTML with CSS selectors using the `xselect` widget and operator.\n* XML tiddlers display correctly, and support XML processing instructions to render using a template tiddler.\n* Allows for importing and exporting XML files.\n\nSee [[the demo website|https://flibbles.github.io/tw5-xml/]] for documentation and examples.\n"
        },
        "$:/config/flibbles/relink/attributes/$xpath/tiddler": {
            "title": "$:/config/flibbles/relink/attributes/$xpath/tiddler",
            "text": "title"
        },
        "$:/config/flibbles/relink/attributes/$xpath/template": {
            "title": "$:/config/flibbles/relink/attributes/$xpath/template",
            "text": "title"
        },
        "$:/config/flibbles/relink/attributes/$xselect/tiddler": {
            "title": "$:/config/flibbles/relink/attributes/$xselect/tiddler",
            "text": "title"
        },
        "$:/config/flibbles/relink/attributes/$xselect/template": {
            "title": "$:/config/flibbles/relink/attributes/$xselect/template",
            "text": "title"
        },
        "$:/plugins/flibbles/xml/widgets.js": {
            "title": "$:/plugins/flibbles/xml/widgets.js",
            "text": "/*\\\ntitle: $:/plugins/flibbles/xml/widgets.js\ntype: application/javascript\nmodule-type: widget\n\nxslt widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\nvar xmldom = require(\"./xmldom\");\nvar xpath = require(\"./xpath\");\nvar xselect = require(\"./xselect\");\n\nvar DOMWidget = function() {};\n\nDOMWidget.prototype = new Widget();\n\nDOMWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tthis.renderChildren(parent,nextSibling);\n};\n\nDOMWidget.prototype.execute = function() {\n\tthis.template = this.getAttribute(\"template\");\n\tthis.foreach = this.getAttribute(\"for-each\");\n\tthis.valueof = this.getAttribute(\"value-of\");\n\tthis.variableName = this.getAttribute(\"variable\", \"currentNode\");\n\tthis.xmlTitle = this.getAttribute(\"tiddler\",this.getVariable(\"currentTiddler\"));\n\tfor (var attribute in this.attributes) {\n\t\tif (attribute.substr(0, 6) === \"xmlns:\") {\n\t\t\tthis.setVariable(attribute,this.attributes[attribute]);\n\t\t}\n\t}\n\n\tvar members = [];\n\tvar contextVariable = this.variables[this.variableContext()];\n\tvar contextNode, doc;\n\tif (contextVariable) {\n\t\tcontextNode = contextVariable.node;\n\t\tdoc = contextNode.ownerDocument || contextNode;\n\t} else {\n\t\tdoc = this.wiki.getTiddlerDocument(this.xmlTitle);\n\t\tcontextNode = doc;\n\t}\n\tif (contextNode) {\n\t\tif (doc.error) {\n\t\t\tmembers.push(this.makeErrorTree(doc.error));\n\t\t} else {\n\t\t\tif (this.foreach) {\n\t\t\t\tvar node = undefined;\n\t\t\t\ttry {\n\t\t\t\t\tvar iterator = this.queryAll(this.foreach, contextNode);\n\t\t\t\t\tnode = iterator.iterateNext();\n\t\t\t\t} catch(e) {\n\t\t\t\t\tvar error = this.handleQueryError(e, this.foreach);\n\t\t\t\t\tmembers.push(this.makeErrorTree(error));\n\t\t\t\t}\n\t\t\t\twhile (node) {\n\t\t\t\t\tvar value;\n\t\t\t\t\tif (this.valueof) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar subnode = this.query(this.valueof, node);\n\t\t\t\t\t\t\tif (subnode) {\n\t\t\t\t\t\t\t\tvalue = xmldom.getStringValue(subnode);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvalue = \"\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\tvar error = this.handleQueryError(e, this.valueof);\n\t\t\t\t\t\t\tmembers.push(this.makeErrorTree(error));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = node.nodeValue || node.innerHTML;\n\t\t\t\t\t\tif (!value && node.documentElement) {\n\t\t\t\t\t\t\tvalue = node.documentElement.outerHTML;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmembers.push(this.makeItemTemplate(node, value, true));\n\t\t\t\t\tnode = iterator.iterateNext();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tnode = this.query(this.valueof, contextNode);\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tvar value = xmldom.getStringValue(node);\n\t\t\t\t\t\tmembers.push(this.makeItemTemplate(null, value, false));\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tvar error = this.handleQueryError(e, this.valueof);\n\t\t\t\t\tmembers.push(this.makeErrorTree(error));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.makeChildWidgets(members);\n};\n\nDOMWidget.prototype.makeErrorTree = function(error) {\n\treturn {type: \"element\", tag: \"span\", attributes: {\n\t\t\t\"class\": {type: \"string\", value: \"tc-error\"}\n\t\t}, children: [\n\t\t\t{type: \"text\", text: error}\n\t\t]};\n};\n\n/*\nCompose the template for a list item\n*/\nDOMWidget.prototype.makeItemTemplate = function(node, value, repeats) {\n\tvar templateTree;\n\t// Compose the transclusion of the template\n\tif(this.template) {\n\t\ttemplateTree = [{type: \"transclude\", attributes: {tiddler: {type: \"string\", value: this.template}}}];\n\t} else {\n\t\tif(this.parseTreeNode.children && this.parseTreeNode.children.length > 0) {\n\t\t\ttemplateTree = this.parseTreeNode.children;\n\t\t} else {\n\t\t\t// Default template is to print out each result\n\t\t\ttemplateTree = {type: \"text\", text: value};\n\t\t\tif (repeats) {\n\t\t\t\ttemplateTree = [{type: \"element\", tag: this.parseTreeNode.isBlock ? \"div\" : \"span\", children: [templateTree]}];\n\t\t\t} else {\n\t\t\t\t// Just returning the value. That's all.\n\t\t\t\treturn templateTree;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the list item\n\treturn {type: \"domnode\", contextName: this.variableContext(), node: node, variableName: this.variableName, variableValue: value, children: templateTree};\n};\n\nDOMWidget.prototype.variableContext = function() {\n\treturn \"xml-node-state-\" + this.xmlTitle;\n};\n\nDOMWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(changedAttributes[\"for-each\"] || changedAttributes[\"value-of\"] || changedAttributes.variable || changedAttributes.tiddler || changedAttributes.template || changedTiddlers[this.xmlTitle] || namespacesChanged(changedAttributes)) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn this.refreshChildren(changedTiddlers);\n\t}\n};\n\nfunction namespacesChanged(changedAttributes) {\n\tfor (var attribute in changedAttributes) {\n\t\tif (attribute.substr(0,6) == \"xmlns:\") {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\n\n/*\nWidget exists for each loop of XPathWidget. Holds current state of\nthat iteration.\n*/\nvar DOMNodeWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\nDOMNodeWidget.prototype = new Widget();\n\nDOMNodeWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tthis.renderChildren(parent,nextSibling);\n};\n\n/*\nCompute the internal state of the widget\n*/\nDOMNodeWidget.prototype.execute = function() {\n\t// Set the current list item title\n\tvar node = this.parseTreeNode.node;\n\tthis.setVariable(this.parseTreeNode.variableName,this.parseTreeNode.variableValue);\n\tif (this.parseTreeNode.node) {\n\t\tthis.setVariable(this.parseTreeNode.contextName,this.parseTreeNode.node.localName);\n\t\tthis.variables[this.parseTreeNode.contextName].node = this.parseTreeNode.node;\n\t}\n\t// Construct the child widgets\n\tthis.makeChildWidgets();\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nDOMNodeWidget.prototype.refresh = function(changedTiddlers) {\n\treturn this.refreshChildren(changedTiddlers);\n};\n\nexports.domnode = DOMNodeWidget;\n\n///////// XPath Widget /////////\n\nfunction XPathWidget(parseTreeNode, options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\nXPathWidget.prototype = new DOMWidget();\n\nexports.xpath = XPathWidget;\n\nXPathWidget.prototype.queryAll = function(xpathQuery, contextNode) {\n\tvar resolver = xpath.createResolver(contextNode, this);\n\tvar iterator = xpath.evaluate(xpathQuery, contextNode, resolver);\n\treturn iterator;\n};\n\nXPathWidget.prototype.query = function(xpathQuery, contextNode) {\n\tvar resolver = xpath.createResolver(contextNode, this);\n\tvar iterator = xpath.evaluate(xpathQuery, contextNode, resolver);\n\treturn iterator.iterateNext();\n};\n\nXPathWidget.prototype.handleQueryError = function(error, offendingQuery) {\n\treturn xpath.getError(error, offendingQuery, this.xmlTitle);\n};\n\n///////// XSelect Widget /////////\n\nfunction XSelectWidget(parseTreeNode, options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\nXSelectWidget.prototype = new DOMWidget();\n\nexports.xselect = XSelectWidget;\n\nXSelectWidget.prototype.queryAll = function(selector, contextNode) {\n\treturn xselect.querySelectorAll(selector, contextNode);\n};\n\nXSelectWidget.prototype.query = function(selector, contextNode) {\n\treturn xselect.querySelector(selector, contextNode);\n};\n\nXSelectWidget.prototype.handleQueryError = function(error, offendingQuery) {\n\treturn xselect.getError(error, offendingQuery);\n};\n\n})();\n",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/flibbles/xml/wikimethods.js": {
            "title": "$:/plugins/flibbles/xml/wikimethods.js",
            "text": "/*\\\ntitle: $:/plugins/flibbles/xml/wikimethods.js\ntype: application/javascript\nmodule-type: wikimethod\n\n\\*/\n\nvar xmldom = require(\"./xmldom\");\n\n/**If the given title is a valid DOM type and the text is valid, returns that.\n * If title doesn't exist, isn't a DOM type, or fails to parse, returns  undefined.\n *\n * Do not edit the returned documents.\n * They would be deep frozen if that wasn't so expensive.\n */\nexports.getTiddlerDocument = function(titleOrTiddler) {\n\tvar tiddler = titleOrTiddler;\n\tif(!(tiddler instanceof $tw.Tiddler)) {\n\t\ttiddler = this.getTiddler(tiddler);\n\t}\n\tif (tiddler) {\n\t\treturn this.getCacheForTiddler(tiddler.fields.title, \"XMLDOM\", function() {\n\t\t\tvar doc = xmldom.getDocumentForText(tiddler.fields.type, tiddler.fields.text);\n\t\t\tif (doc && doc.error) {\n\t\t\t\t// Let's elaborate\n\t\t\t\tvar errorKey = \"flibbles/xml/Error/DOMParserError\";\n\t\t\t\tdoc.error = $tw.language.getString(errorKey,\n\t\t\t\t\t{variables: {currentTiddler: tiddler.fields.title}});\n\t\t\t}\n\t\t\treturn doc;\n\t\t});\n\t} else {\n\t\treturn undefined;\n\t}\n};\n",
            "type": "application/javascript",
            "module-type": "wikimethod"
        },
        "$:/plugins/flibbles/xml/xmldom.js": {
            "title": "$:/plugins/flibbles/xml/xmldom.js",
            "text": "/*\\\ntitle: $:/plugins/flibbles/xml/xmldom.js\ntype: application/javascript\nmodule-type: library\n\nMakes available the XMLDom, either through a browser's native support, or\nthe tiddlywiki plugin.\n\\*/\n\nexports.getDocumentForText = function(type, text) {\n\tvar supportedType = $tw.config.xml.supportedDocumentTypes[type];\n\tif (!supportedType) {\n\t\treturn undefined;\n\t}\n\treturn getParseFromString()(text, supportedType);\n};\n\n/* Gets <?tiddlywiki attributes?> present at document's root.\n */\nexports.getProcessingInstructions = function(doc) {\n\tvar attributes = Object.create(null);\n\tvar node = doc.firstChild;\n\twhile (node) {\n\t\tif (node.target === \"tiddlywiki\") {\n\t\t\tvar pos = 0;\n\t\t\tvar attribute = $tw.utils.parseAttribute(node.data, pos);\n\t\t\twhile (attribute) {\n\t\t\t\tattributes[attribute.name] = attribute;\n\t\t\t\tpos = attribute.end;\n\t\t\t\tattribute = $tw.utils.parseAttribute(node.data, pos);\n\t\t\t}\n\t\t}\n\t\tnode = node.nextSibling;\n\t}\n\treturn attributes;\n};\n\nexports.getStringValue = function(node) {\n\tvar value = node.nodeValue || node.textContent;\n\tif (!value && node.documentElement) {\n\t\tvalue = node.documentElement.textContent;\n\t}\n\treturn value;\n};\n\nvar _DOMParser = undefined;\nvar _parseFromString = undefined;\n\nfunction getParseFromString() {\n\tif (_parseFromString === undefined) {\n\t\tif ($tw.browser) {\n\t\t\t_DOMParser = DOMParser;\n\t\t\t_parseFromString = parseFromStringInBrowser;\n\t\t} else {\n\t\t\tvar DOM;\n\t\t\ttry {\n\t\t\t\tDOM = require('xmldom');\n\t\t\t} catch (e) {\n\t\t\t\tDOM = require(\"$:/plugins/tiddlywiki/xmldom/dom-parser\");\n\t\t\t}\n\t\t\t_DOMParser = DOM.DOMParser;\n\t\t\t_parseFromString = parseFromStringInNodeJS;\n\t\t\tvar doc = _parseFromString(\"<elem/>\");\n\t\t\tvar docProto = Object.getPrototypeOf(doc);\n\t\t\tvar nodeProto = Object.getPrototypeOf(doc.documentElement);\n\t\t\tObject.defineProperty(nodeProto, \"innerHTML\", { get: innerHTML });\n\t\t\tObject.defineProperty(nodeProto, \"outerHTML\", { get: outerHTML });\n\t\t\tif (!doc.documentElement.compareDocumentPosition) {\n\t\t\t\tnodeProto.compareDocumentPosition = compareDocumentPosition;\n\t\t\t}\n\t\t\tif (!doc.compareDocumentPosition) {\n\t\t\t\tdocProto.compareDocumentPosition = function(node) {\n\t\t\t\t\treturn (node.ownerDocument == this) ? 20 : 33;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\treturn _parseFromString;\n};\n\nfunction parseFromStringInBrowser(text, type) {\n\tvar parser = new _DOMParser();\n\tvar doc = parser.parseFromString(text, type);\n\tvar errors = doc.getElementsByTagName(\"parsererror\");\n\tif (errors.length > 0) {\n\t\t// If the xml doc already contained parsererror\n\t\t// elements, then we have no reliable way to\n\t\t// detect parse errors on the browser, so just\n\t\t// greenlight and hope for the best.\n\t\tif (text.indexOf(\"<parsererror\") < 0) {\n\t\t\tdoc.error = true;\n\t\t}\n\t}\n\treturn doc;\n};\n\nfunction parseFromStringInNodeJS(text, type) {\n\tvar errorDetected = false;\n\tfunction flag() { errorDetected = true; };\n\tvar parser = new _DOMParser({\n\t\terrorHandler: {\n\t\t\terror: flag,\n\t\t\twarning: flag,\n\t\t\tfatalError: flag\n\t\t}\n\t});\n\tvar doc = parser.parseFromString(text, type);\n\tif (errorDetected) {\n\t\tdoc.error = true;\n\t}\n\tif (!doc.documentElement && text.indexOf(\"<html>\") < 0) {\n\t\t// This is one of those weird halfbaked documents that Node.js\n\t\t// sometimes returns if it's text only. Just wrap it ourselves.\n\t\tdoc = parseFromStringInNodeJS(type, \"<html><body>\"+text+\"</html></body>\");\n\t}\n\treturn doc;\n};\n\n/////// Substitute methods ///////\n\nfunction innerHTML() {\n\tvar child = this.firstChild;\n\t\tbuffer = [];\n\twhile (child) {\n\t\tbuffer.push(child.toString());\n\t\tchild = child.nextSibling;\n\t}\n\treturn buffer.join('');\n};\n\nfunction outerHTML() {\n\treturn this.toString();\n};\n\n// This is a cheap standin compare method used for Node.JS implementations\n// Needed for css, and not xpath. Hopefully I never need this for attributes.\nfunction compareDocumentPosition(target) {\n\tvar tree = [];\n\tvar ptr = this;\n\t// Build tree of this's ancestors.\n\twhile (ptr) {\n\t\ttree.push(ptr);\n\t\tptr = ptr.parentNode || ptr.ownerElement;\n\t}\n\t// Find common ancestory\n\tptr = target;\n\tvar index = -1, prev = null;\n\twhile (ptr) {\n\t\tif ((index = tree.indexOf(ptr)) >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tprev = ptr;\n\t\tptr = ptr.parentNode || ptr.ownerElement;\n\t}\n\tif (index < 0) {\n\t\t// Disconnected\n\t\treturn 33;\n\t}\n\tif (index == 0) {\n\t\t// target is descendant of this\n\t\treturn 20;\n\t}\n\tif (prev == null) {\n\t\t// target is ancestor of this\n\t\treturn 10\n\t}\n\twhile (tree.indexOf(prev) < 0) {\n\t\tprev = prev.nextSibling;\n\t\tif (!prev) {\n\t\t\t// End of the line. B's ancestor in ptr must come after this's\n\t\t\treturn 4;\n\t\t}\n\t}\n\t// Match. B's ancestor under ptr comes before this\n\treturn 2;\n};\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/flibbles/xml/xpath.js": {
            "title": "$:/plugins/flibbles/xml/xpath.js",
            "text": "/*\\\ntitle: $:/plugins/flibbles/xml/xpath.js\ntype: application/javascript\nmodule-type: library\n\nMakes available XPath, either through a browser's native support, or\nthe node.JS library\n\\*/\n\nexports.evaluate = function(xpathExpression, contextNode, namespaceResolver) {\n\tvar xpath = getXPath();\n\treturn xpath.evaluate(xpathExpression, contextNode, namespaceResolver, xpath.XPathResult.ANY_TYPE, null);\n};\n\n/**This attempts to build a consistent error message from an xpath\n * \"evaluate\" exception. Different implementations act differently. This\n * Tries to reconcile them all into an error message in a tiddler language\n * string.\n */\nexports.getError = function(exception, query, title) {\n\tvar code, msg;\n\tswitch (exception.name) {\n\t\tcase \"UnsupportedBrowserError\": // I made this one up\n\t\tcase \"MissingDependenciesError\": // I made this one up\n\t\tcase \"NamespaceError\":\n\t\tcase \"SyntaxError\":\n\t\t\tcode = exception.name;\n\t\t\tbreak;\n\t\tcase \"Error\":\n\t\t\tif (exception.message.indexOf(\"Cannot resolve QName\") == 0) {\n\t\t\t\tcode = \"NamespaceError\";\n\t\t\t} else if (exception.message.indexOf(\"Invalid expression\") == 0) {\n\t\t\t\tcode = \"SyntaxError\";\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tif (code) {\n\t\tmsg = $tw.language.getString(\"flibbles/xml/Error/XPath/\" + code,\n\t\t\t{variables: {xpath: query, currentTiddler: title}});\n\t} else {\n\t\t// This message will be wildly inconsistent across implementations,\n\t\t// but it's better that we show this than something generic.\n\t\tmsg = exception.message;\n\t\tconsole.warn(exception.code);\n\t\tconsole.warn(exception.name);\n\t\tconsole.warn(exception.message);\n\t\tconsole.warn(exception);\n\t}\n\treturn msg;\n};\n\nexports.createResolver = function(contextNode, widget) {\n\tvar resolver, docResolver = getXPath().createNSResolver(contextNode);\n\tif (widget) {\n\t\tresolver = function(nsPrefix) {\n\t\t\tvar variable = widget.variables[\"xmlns:\" + nsPrefix];\n\t\t\treturn variable ? variable.value : docResolver.lookupNamespaceURI(nsPrefix);\n\t\t};\n\t\t// Some implementations expect an object with this method, not a\n\t\t// function. We must abide.\n\t\tresolver.lookupNamespaceURI = resolver;\n\t} else {\n\t\tresolver = docResolver;\n\t}\n\treturn resolver;\n};\n\nvar _xpath = undefined;\n\nfunction getXPath() {\n\tif (_xpath === undefined) {\n\t\t_xpath = Object.create(null);\n\t\tif ($tw.browser) {\n\t\t\tif (!window.XPathResult) {\n\t\t\t\tfunction unsupported() {\n\t\t\t\t\tthrow {name: \"UnsupportedBrowserError\"};\n\t\t\t\t};\n\t\t\t\t_xpath.XPathResult = Object.create(null);\n\t\t\t\t_xpath.evaluate = unsupported;\n\t\t\t\t_xpath.createNSResolver = unsupported;\n\t\t\t} else {\n\t\t\t\t_xpath.XPathResult = XPathResult;\n\t\t\t\t_xpath.evaluate = function(xpathExpression, contextNode, namespaceResolver, resultType, result) {\n\t\t\t\t\tvar doc = contextNode.ownerDocument || contextNode;\n\t\t\t\t\treturn doc.evaluate(xpathExpression, contextNode, namespaceResolver, resultType, result);\n\t\t\t\t}\n\t\t\t\t_xpath.createNSResolver = function(node) {\n\t\t\t\t\tvar doc = node.ownerDocument || node;\n\t\t\t\t\treturn doc.createNSResolver(node);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tvar xpath = require('xpath');\n\t\t\t\t_xpath.XPathResult = xpath.XPathResult;\n\t\t\t\t_xpath.evaluate = xpath.evaluate;\n\t\t\t\t_xpath.createNSResolver = xpath.createNSResolver;\n\t\t\t} catch (e) {\n\t\t\t\tfunction unresolved() {\n\t\t\t\t\tthrow {name: \"MissingDependenciesError\"};\n\t\t\t\t};\n\t\t\t\t_xpath.evaluate = unresolved;\n\t\t\t\t_xpath.createNSResolver = unresolved;\n\t\t\t\t_xpath.XPathResult = Object.create(null);\n\t\t\t}\n\t\t}\n\t}\n\treturn _xpath;\n};\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/flibbles/xml/xselect.js": {
            "title": "$:/plugins/flibbles/xml/xselect.js",
            "text": "/*\\\ntitle: $:/plugins/flibbles/xml/xselect.js\ntype: application/javascript\nmodule-type: library\n\nMakes available querySelector, either through a browser's native support, or\nthe node.JS library\n\\*/\n\nvar _selector = undefined;\n\nexports.querySelector = function(cssSelector, contextNode) {\n\treturn getSelector().querySelector(cssSelector, contextNode);\n};\n\nexports.querySelectorAll = function(cssSelector, contextNode) {\n\tvar nodeList = getSelector().querySelectorAll(cssSelector, contextNode);\n\treturn new QueryIterator(nodeList);\n};\n\nfunction QueryIterator(nodeList) {\n\tthis.nodeList = nodeList;\n\tthis.index = 0;\n};\n\nQueryIterator.prototype.iterateNext = function() {\n\treturn this.nodeList[this.index++];\n};\n\nexports.getError = function(exception, cssSelector) {\n\t// All we do currently is say that the query is bad. No details.\n\tif (exception.name === \"TypeError\") {\n\t\t// This is an unexpected type of error. Not syntax. Just print it.\n\t\treturn exception.message;\n\t}\n\treturn $tw.language.getString(\"flibbles/xml/Error/XSelect/SyntaxError\",\n\t\t{variables: {xselect: cssSelector}});\n};\n\nfunction getSelector() {\n\tif (_selector === undefined) {\n\t\t_selector = Object.create(null);\n\t\tif ($tw.browser) {\n\t\t\t_selector.querySelector = function(cssSelector, contextNode) {\n\t\t\t\treturn contextNode.querySelector(cssSelector);\n\t\t\t};\n\t\t\t_selector.querySelectorAll = function(cssSelector, contextNode) {\n\t\t\t\treturn contextNode.querySelectorAll(cssSelector);\n\t\t\t};\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tvar querySelectorAll = require(\"query-selector\").default;\n\t\t\t\t_selector.querySelectorAll = querySelectorAll;\n\t\t\t\t_selector.querySelector = function(cssSelector, contextNode) {\n\t\t\t\t\tvar nodeList = querySelectorAll(cssSelector, contextNode);\n\t\t\t\t\treturn nodeList[0];\n\t\t\t\t};\n\t\t\t} catch (e) {\n\t\t\t\tfunction unsupported() {\n\t\t\t\t\tthrow \"query-selector is required on Node.JS for this operation. Install xpath with 'npm install query-selector'\";\n\t\t\t\t};\n\t\t\t\t_selector.querySelector = unsupported;\n\t\t\t\t_selector.querySelectorAll = unsupported;\n\t\t\t}\n\t\t}\n\t}\n\treturn _selector;\n};\n",
            "type": "application/javascript",
            "module-type": "library"
        }
    }
}